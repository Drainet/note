<!DOCTYPE html>
<html>
  <head>
    <title>Rust Memory Ownership</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-solarized-dark.min.css"/>
  </head>
<body><h2 id="rust-memory-ownership"><a class="header-link" href="#rust-memory-ownership"></a>Rust Memory Ownership</h2>
<p>本篇將我閱讀 <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Ownership</a> 與 <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Lifetime</a> 的理解寫出來</p>
<p>Rust 是最近非常熱門的一個程式語言，主要原因是它擁有許多現代高階語言會有的語言特性，同時又能寫出效能逼近 C 語言的程式，其中的主要原因便在於 Rust 獨特的記憶體管理方式，Rust 不使用 GC 或是 Reference Counting 的方式控管記憶體，同時又不會像 C 語言那樣手動控管記憶體容易出錯，讀完 Ownership 與 Lifetime 之後我的理解是：Rust 設計了一些規則讓開發者遵守從而達到在 compile time 就能知道所有記憶體需要被調用與釋放的時機。</p>
<h3 id="stack-與-heap"><a class="header-link" href="#stack-與-heap"></a>Stack 與 Heap</h3>
<p>與其他語言一樣，Rust 中的變數分為存放在 stack 上與 heap 上，基本上在 compile time 就能知道佔用記憶體大小的 variable 會存放在 stack 上，像 <code>String</code> 這種 data type 由於使用的記憶體用量會髓著程式邏輯動態增減，無法在 compile 時就知道佔用記憶體大小，則會在 Stack 上存放指向實際上儲存資料的 Heap 的指標。在其他程式語言如 Java，工程師其實不需要知道資料是存在 Stack 或 Heap (大部分狀況啦...)，然而 Rust 開發者是必須要知道的，因為這會實際上影響到在程式碼該如何操控變數。</p>
<h3 id="ownership-與-scope"><a class="header-link" href="#ownership-與-scope"></a>Ownership 與 Scope</h3>
<p>每個在 Rust 程式碼中的 value 都有一個 <strong>Owner</strong>，而這個 Owner 就是指向它的 variable，而<strong>一個 value 同時只會有一個 Owner</strong>，variable 會屬於一個 <strong>Scope</strong> 內，當這個 Scope 結束後 variable 的 value 會被釋放掉。以下面程式碼為例，<code>&quot;hello&quot;</code> 這個 value 的 owner 是 variable <code>s</code>，上下括號測是這個 variable 存在的 Scope。</p>
<pre class="hljs"><code>{
  <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>;
}</code></pre><h3 id="copy-與-ownership-轉移"><a class="header-link" href="#copy-與-ownership-轉移"></a>Copy 與 Ownership 轉移</h3>
<p>在上面有說到變數存在 Stack 與 Heap 上會影響到在程式碼上如何操控變數：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> y = x;</code></pre><p>上述的程式碼中，由於 5 是存在 Stack 上的，第二行的 <code>y = x</code> 會直接將 x 所指到的 value 也就是 5 copy 一份給 y。</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> s2 = s1;</code></pre><p>上面的程式碼，由於 String type 是存在 Heap 中，<code>s2</code> 只有 copy <code>s1</code> 在 Stack 上的指標與相關資訊並指到同一個 Heap，讀到這裡可能還覺得沒什麼新東西跟 Java 差不多，但現在問題來了，上面說一個 value 只會有一個 Owner，那將 <code>s2</code> 指向 <code>s1</code> 之後這個 String value 的 Owner 是誰呢？一個 value 同時擁有兩個 Owner 會造成無法在 compile time 判斷 value 何時要被釋放，Rust 的解法是：當你使用 <code>s2</code> 指向 <code>s1</code> 時，<code>s1</code> 已經不能再被使用了，從這行以後 <code>s2</code> 是 Owner。</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> s2 = s1;
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}, world!&quot;</span>, s1);</code></pre><p>上面這段程式碼會無法 compile，因為在 <code>s1</code> 已經把 Ownership 轉移給 <code>s2</code> 之後又使用到了已經無效的 <code>s1</code> 變數。</p>
<p>當然 String 這種 data type 還是可以使用 <code>clone</code> 去做 deep copy：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> s2 = s1.clone();
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = {}, s2 = {}&quot;</span>, s1, s2);</code></pre><p>在上述程式碼中， <code>s1.clone()</code> 直接將 heap 中的資料也複製了一份並讓 <code>s2</code> 指過去，如此就兩個不同的 value 也各自有不同 Owner 故在第三行能同時使用兩個變數。</p>
<h3 id="function-的-ownership-轉移"><a class="header-link" href="#function-的-ownership-轉移"></a>Function 的 Ownership 轉移</h3>
<p>在呼叫 function 時也會發生 Ownership 轉移：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> </span>() {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
  makes_copy(x);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, x);
  <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  takes_ownership(s);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, s);<span class="hljs-comment">//compile error</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(integer: <span class="hljs-built_in">i32</span>) {
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, integer);
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_ownership</span></span>(string: <span class="hljs-built_in">String</span>) {
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, string);
}</code></pre><p>上述程式碼中其實慨念上跟前一部份提到的差不多，同樣在呼叫 <code>makes_copy</code> 時因為 value 存在 stack 上，會直接 copy 一份給 function 內部使用不影響原本 <code>x</code> 的 Ownership，所以在呼叫完之後還是能繼續使用，然而呼叫 <code>takes_ownership</code> 時 Ownership 就轉移給 function 內部的 <code>string</code> 了，所以第七行程式碼會導致 compile error，因為 Ownership 已經被轉移了。
然後 function 也可以透過 return value 將 Ownership 轉移給呼叫方：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  <span class="hljs-keyword">let</span> s2 = takes_and_give_back(s1);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, s2);
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_give_back</span></span>(string: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
  string <span class="hljs-comment">//rust 能省略 return 直接將最後 expression 作為 return value</span>
}</code></pre><p>如此就能在呼叫 function 後繼續操控原本字串。</p>
<h3 id="references-與-borrowing"><a class="header-link" href="#references-與-borrowing"></a>References 與 Borrowing</h3>
<p>如果呼叫 function 都要上述方式將值回傳說真的也太麻煩了，在 Rust 提供了以下寫法解決這個問題：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
    <span class="hljs-keyword">let</span> len = calculate_length(&amp;s1);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;{}&#x27; is {}.&quot;</span>, s1, len);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> {
    s.len()
}</code></pre><p>上述 function <code>calculate_length</code> 會在呼叫時回傳字串長度，可以看到在呼叫 function 時傳入的是 <code>&amp;s1</code> 以及定義在 function 上的型別是 <code>&amp;String</code>，其中 <code>&amp;s1</code> 代表的是創造一個 <strong>Reference</strong> 指標指向 <code>s1</code> 指標，並沒有轉移 Ownership，<code>&amp;String</code> 則指定傳進來的要是 Reference type，所以在 calculate_length 執行完畢時，因為 s 是 Reference 指標，並沒有任何記憶體被釋放掉。在原 Scope 也能繼續使用 <code>s1</code>。</p>
<h3 id="mutable-references"><a class="header-link" href="#mutable-references"></a>Mutable References</h3>
<p>若嘗試在 function 內操作 Reference 指標更改其的值：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  change(&amp;s);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">change</span></span>(some_string: &amp;<span class="hljs-built_in">String</span>) {
  some_string.push_str(<span class="hljs-string">&quot;, world&quot;</span>);
}</code></pre><p>上述的程式碼會 compile 失敗，因為試圖對一個 Reference 指標的值進行修改。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
    change(&amp;<span class="hljs-keyword">mut</span> s);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">change</span></span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) {
    some_string.push_str(<span class="hljs-string">&quot;, world&quot;</span>);
}</code></pre><p>上面的程式碼可以成功 compile 跟運作，首先在宣告 s 變數時加了 <code>mut</code> 宣告這是一個可變變數，命且在原本只使用 <code>＆</code> 的地方改使用 <code>&amp;mut</code> 宣告這是 mutable reference，這樣便可在 function 中對於外部 Reference 進行的值進行更改。
但 mutable reference 指標是有限制的，那就是不能同時將兩個 mutable reference 指標指向同一個指標：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;
<span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}, {}&quot;</span>, r1, r2);</code></pre><p>上述程式碼會 compile 失敗，因為 <code>r1</code> 與 <code>r2</code> 都嘗試創造 mutable reference 指向 <code>s</code>，基本上這個限制是為了防止 data race，<code>r1</code> 與 <code>r2</code> 若都能對 s 的值進行修改則程式很容易出現為定義的行為。
但要注意的是這個限制是不能&quot;同時&quot;兩個 mutable reference 指標指向同一個指標，所以透過 Scope 的控制，以下程式碼也是合法的：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
{
  <span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;
} 
<span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;</code></pre><p>因為將 <code>r1</code> 額外用括號所在另一個比較小的 Scope，Scope 結束後 <code>r1</code> 也就消失了，所以此時可以再宣告 <code>r2</code> 不會發生問題。
同一時間擁有多個 Reference 指在同一個變數是合法的：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> r1 = &amp;s;
<span class="hljs-keyword">let</span> r2 = &amp;s;
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{} and {}&quot;</span>, r1, r2);</code></pre><p>然而在同一時間，若已經有普通的 Reference 指在一個變數上，就不能有 mutable reference 指在同樣的變數上：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> r1 = &amp;s;
<span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;</code></pre><p>上述的程式碼會 compile 失敗，因為 <code>r1</code> 已經創造了一個 Reference 指向 <code>s</code>，<code>r2</code> 沒辦法再對 <code>s</code> 創造 mutable refecence。然而還是要記住限制是&quot;同時&quot;，所以下程式碼是合法的：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> r1 = &amp;s;
<span class="hljs-keyword">let</span> r2 = &amp;s;
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{} and {}&quot;</span>, r1, r2);
<span class="hljs-keyword">let</span> r3 = &amp;<span class="hljs-keyword">mut</span> s;
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, r3);</code></pre><p>以上程式碼因為 <code>r1</code> 與 <code>r2</code> 在呼叫 <code>println</code> 已經把 Reference 的 Ownership 轉移給 <code>println</code> 了所以已經離開 Scope，故能合法宣告 <code>r3</code>。</p>
<h2 id="dangling-references"><a class="header-link" href="#dangling-references"></a>Dangling References</h2>
<p>Rust 也能在 compile time 防止創造出 <strong>dangling pointer</strong>，即是防止繼續使用指向的記憶體已經被釋放掉的指標：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> reference_to_nothing = dangle();
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dangle</span></span>() -&gt; &amp;<span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  &amp;s
}</code></pre><p>上述程式碼會 compile 失敗，因為 fuction <code>dangle</code> 嘗試回傳的 Reference 所指向的變數在這個 Scope 就會被釋放掉。</p>
<h2 id="slice-type"><a class="header-link" href="#slice-type"></a>Slice Type</h2>
<p>內建的 String 與其他一些 Collection type 提供了 slice 的 API，以 String 為例，能創在一個 Reference 指向 String 區段的 substring：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);
<span class="hljs-keyword">let</span> hello = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> world = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];</code></pre><p>其中 <code>0..5</code> 這是 Range 的 literal，所以基本上 API 的形式是這樣 <code>&amp;s[Range]</code>，然後因為 String 這個 type 不是以 <code>[char]</code> 這種 type 來表示，所以 String 的 slice 有另外一個 type：<code>&amp;str</code>：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
  <span class="hljs-keyword">let</span> bytes = s.as_bytes();
  <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() {
    <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> {
      <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i];
    }
  }
  &amp;s[..]
}</code></pre><p>有趣的是像 <code>&quot;hello world&quot;</code> 這個 literal 其實就是 <code>&amp;str</code> type，所以如果設計 Rust 的 function 直接使用 <code>&amp;str</code> 來當作 parameter type 使用上會更加方便：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> my_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);
  <span class="hljs-keyword">let</span> word = first_word(&amp;my_string[..]);
  <span class="hljs-keyword">let</span> my_string_literal = <span class="hljs-string">&quot;hello world&quot;</span>;
  <span class="hljs-keyword">let</span> word = first_word(&amp;my_string_literal[..]);
  <span class="hljs-keyword">let</span> word = first_word(my_string_literal);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
<span class="hljs-comment">//...</span></code></pre><p>而使用 Slice type 來指向變數因為也是創造一個 Reference，所以也會防止變數被改變：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);
  <span class="hljs-keyword">let</span> word = first_word(&amp;s);
  s.clear();
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the first word is: {}&quot;</span>, word);
}</code></pre><p>上述程式碼不會 compile 成功，這也保證了使用 Slice type 的安全性。
其他內建的 Collection type 也都支援 Slice API，而因為本身就是 Collection type，所以像是 <code>[i32]</code> 的 slice type 就是很直覺的像這樣表示：<code>&amp;[i32]</code>。</p>
<h3 id="lifetime"><a class="header-link" href="#lifetime"></a>Lifetime</h3>
<p><strong>Lifetime</strong> 指的其實就是一個 variable 能夠存活的 Scope，大部分的時候 Lifetime 都有辦法靠 Scope 自動偵測，像是到目前為止提到過的程式碼，Lifetime 都是有辦法自動偵測的，但還是會出現無法自動偵測的狀況，就需要接下來提到的 Lifetime Annotation Syntax 來解決。</p>
<h3 id="lifetime-annotation-syntax"><a class="header-link" href="#lifetime-annotation-syntax"></a>Lifetime Annotation Syntax</h3>
<p>看看以下的程式碼邏輯：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> string1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;abcd&quot;</span>);
  <span class="hljs-keyword">let</span> string2 = <span class="hljs-string">&quot;xyz&quot;</span>;
  <span class="hljs-keyword">let</span> result = longest(string1.as_str(), string2);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is {}&quot;</span>, result);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest</span></span>(x: &amp;<span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
  <span class="hljs-keyword">if</span> x.len() &gt; y.len() {
    x
  } <span class="hljs-keyword">else</span> {
    y
  }
}</code></pre><p>以上的程式碼 compile 會失敗，主要的原因在 <code>longest</code> 這個 function 回傳的 <code>&amp;str</code> type，這個 <code>&amp;str</code> 是一個 reference type，然而 compiler 無法確認它的 Lifetime 是綁定在哪一個 variable 上，事實上連我們也沒有辦法確認，因為回傳哪個結果是在 runtime 依據 <code>if</code> 的結果來決定的。
官方提供了一個 annotation syntax 來解決這個問題：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> {
  <span class="hljs-keyword">if</span> x.len() &gt; y.len() {
    x
  } <span class="hljs-keyword">else</span> {
    y
  }
}</code></pre><p>其中 <code>&lt;&#39;a&gt;</code> 很像一般的 Generic type 定義語法，差別在於內部一定要使用 (<code>&#39;</code>) 開頭，並且通常是使用非常短的全小寫單字來定義的，<code>&lt;&#39;a&gt;</code> 定義了一個 Lifetime 並且同時加到了傳進來的兩個 parameter 以及 return type 上，這表示回傳的 Reference 的 Lifetime 必須小於等於傳入的兩個 parameter 的 Lifetime，如此 compiler 就有辦法判斷 Lifetime 了：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> string1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;long string is long&quot;</span>);
  {
    <span class="hljs-keyword">let</span> string2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;xyz&quot;</span>);
    <span class="hljs-keyword">let</span> result = longest(string1.as_str(), string2.as_str());
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is {}&quot;</span>, result);
  }
}</code></pre><p>以上程式碼能 compile 成功，因為回傳的 Reference 的 Lifetime 與較小的 <code>string2</code> 一樣在括號內，所以 <code>println</code> 能合法使用 <code>result</code>，反之：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> string1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;long string is long&quot;</span>);
  <span class="hljs-keyword">let</span> result;
  {
    <span class="hljs-keyword">let</span> string2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;xyz&quot;</span>);
    result = longest(string1.as_str(), string2.as_str());
  }
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is {}&quot;</span>, result);
}</code></pre><p>則會 compile 失敗，因為已經過了 <code>string2</code> 所在的 Scope 仍嘗試使用 result。
在使用 Lifetime annotation 的時候也能注意只需要標注到你需要使用的 Lifetime 就好，譬如：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> {
  x
}</code></pre><p>上述程式碼就沒有為 <code>y</code> 標上 annotation，因為 function 直接回傳 <code>x</code>，跟 <code>y</code> 完全沒有關係。
Lifetime annotation 也會強制回傳的 Reference 一定要對應到指定的 Lifetime：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> {
  <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;really long string&quot;</span>);
  result.as_str()
}</code></pre><p>上述程式碼會 compile 失敗，因為回傳的完全是一個跟 <code>x</code> 與 <code>y</code> 毫無相干的 Reference。
同樣的 Annotation 也能用在 <code>struct</code> 上：</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ImportantExcerpt</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
  part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> novel = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Call me Ishmael. Some years ago...&quot;</span>);
  <span class="hljs-keyword">let</span> first_sentence = novel.split(<span class="hljs-string">&#x27;.&#x27;</span>).next().expect(<span class="hljs-string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);
  <span class="hljs-keyword">let</span> i = ImportantExcerpt {
    part: first_sentence,
  };
}</code></pre><p>同樣的規則，<code>first_sentence</code> 的 Lifetime 大於等於 <code>i</code>，所以上述程式碼是合法的。</p>
<h3 id="lifetime-elision"><a class="header-link" href="#lifetime-elision"></a>Lifetime Elision</h3>
<p>可能你有注意到其實在更之前的程式碼就有用到傳入 Reference 並且回傳 Reference 沒加 Lifetime annotation 並且 compile 也能成功，像是這個 function：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
  <span class="hljs-keyword">let</span> bytes = s.as_bytes();
  <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() {
    <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> {
      <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i];
    }
  }
  &amp;s[..]
}</code></pre><p>實際上這段程式碼在 Rust 1.0 以前是沒辦法 compile 的，但是官方有注意到很多人寫這種類型的 function，所以乾脆在這種只有一個 parameter 以及 return type 相同的時候自動在 compile 時幫忙補上 annotation，所以這段程式碼實際上會被轉成這樣：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> {
<span class="hljs-comment">//...</span></code></pre><p>基本上官方創造了一些規則叫做 <strong>lifetime elision rules</strong>，這些規則會在 compile 時偵測所有能夠套用的地方，隨著官方發現開發者還會很常用哪些 pattern，這些規則未來還會持續增加。</p>
<h3 id="the-static-lifetime"><a class="header-link" href="#the-static-lifetime"></a>The Static Lifetime</h3>
<p>還有一個 <code>&#39;static</code> 的關鍵字能指定 Reference 能存活於整個程式的生命週期：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;I have a static lifetime.&quot;</span>;</code></pre></body>
</html>
