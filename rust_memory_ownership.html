<!DOCTYPE html>
<html>
  <head>
    <title>Rust Memory Ownership</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-solarized-dark.min.css"/>
  </head>
<body><h2 id="rust-memory-ownership"><a class="header-link" href="#rust-memory-ownership"></a>Rust Memory Ownership</h2>
<p>本篇將我閱讀 <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Ownership</a> 與 <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Lifetime</a> 的理解寫出來</p>
<p>Rust 是最近非常熱門的一個程式語言，主要原因是它擁有許多現代高階語言會有的語言特性，同時又能寫出效能逼近 C 語言的程式，其中的主要原因便在於 Rust 獨特的記憶體管理方式，Rust 不使用 GC 或是 Reference Counting 的方式控管記憶體，同時又不會像 C 語言那樣手動控管記憶體容易出錯，讀完 Ownership 與 Lifetime 之後我的理解是：Rust 設計了一些規則讓開發者遵守從而達到在 compile time 就能知道所有記憶體需要被調用與釋放的時機。</p>
<h3 id="stack-與-heap"><a class="header-link" href="#stack-與-heap"></a>Stack 與 Heap</h3>
<p>與其他語言一樣，Rust 中的變數分為存放在 stack 上與 heap 上，基本上在 compile time 就能知道佔用記憶體大小的 variable 會存放在 stack 上，像 <code>String</code> 這種 data type 由於使用的記憶體用量會髓著程式邏輯動態增減，無法在 compile 時就知道佔用記憶體大小，則會在 Stack 上存放指向實際上儲存資料的 Heap 的指標。在其他程式語言如 Java，工程師其實不需要知道資料是存在 Stack 或 Heap (大部分狀況啦...)，然而 Rust 開發者是必須要知道的，因為這會實際上影響到在程式碼該如何操控變數。</p>
<h3 id="ownership-與-scope"><a class="header-link" href="#ownership-與-scope"></a>Ownership 與 Scope</h3>
<p>每個在 Rust 程式碼中的 value 都有一個 <strong>Owner</strong>，而這個 Owner 就是指向它的 variable，而<strong>一個 value 同時只會有一個 Owner</strong>，variable 會屬於一個 <strong>Scope</strong> 內，當這個 Scope 結束後 variable 的 value 會被釋放掉。以下面程式碼為例，<code>&quot;hello&quot;</code> 這個 value 的 owner 是 variable <code>s</code>，上下括號測是這個 variable 存在的 Scope。</p>
<pre class="hljs"><code>{
  <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>;
}</code></pre><h3 id="copy-與-ownership-轉移"><a class="header-link" href="#copy-與-ownership-轉移"></a>Copy 與 Ownership 轉移</h3>
<p>在上面有說到變數存在 Stack 與 Heap 上會影響到在程式碼上如何操控變數：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> y = x;</code></pre><p>上述的程式碼中，由於 5 是存在 Stack 上的，第二行的 <code>y = x</code> 會直接將 x 所指到的 value 也就是 5 copy 一份給 y。</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> s2 = s1;</code></pre><p>上面的程式碼，由於 String type 是存在 Heap 中，<code>s2</code> 只有 copy <code>s1</code> 在 Stack 上的指標與相關資訊並指到同一個 Heap，讀到這裡可能還覺得沒什麼新東西跟 Java 差不多，但現在問題來了，上面說一個 value 只會有一個 Owner，那將 <code>s2</code> 指向 <code>s1</code> 之後這個 String value 的 Owner 是誰呢？一個 value 同時擁有兩個 Owner 會造成無法在 compile time 判斷 value 何時要被釋放，Rust 的解法是：當你使用 <code>s2</code> 指向 <code>s1</code> 時，<code>s1</code> 已經不能再被使用了，從這行以後 <code>s2</code> 是 Owner。</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> s2 = s1;
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}, world!&quot;</span>, s1);</code></pre><p>上面這段程式碼會無法 compile，因為在 <code>s1</code> 已經把 Ownership 轉移給 <code>s2</code> 之後又使用到了已經無效的 <code>s1</code> 變數。</p>
<p>當然 String 這種 data type 還是可以使用 <code>clone</code> 去做 deep copy：</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-keyword">let</span> s2 = s1.clone();
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = {}, s2 = {}&quot;</span>, s1, s2);</code></pre><p>在上述程式碼中， <code>s1.clone()</code> 直接將 heap 中的資料也複製了一份並讓 <code>s2</code> 指過去，如此就兩個不同的 value 也各自有不同 Owner 故在第三行能同時使用兩個變數。</p>
<h3 id="function-的-ownership-轉移"><a class="header-link" href="#function-的-ownership-轉移"></a>Function 的 Ownership 轉移</h3>
<p>在呼叫 function 時也會發生 Ownership 轉移：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> </span>() {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
  makes_copy(x);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, x);
  <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  takes_ownership(s);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, s);<span class="hljs-comment">//compile error</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(integer: <span class="hljs-built_in">i32</span>) {
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, integer);
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_ownership</span></span>(string: <span class="hljs-built_in">String</span>) {
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, string);
}</code></pre><p>上述程式碼中其實慨念上跟前一部份提到的差不多，同樣在呼叫 <code>makes_copy</code> 時因為 value 存在 stack 上，會直接 copy 一份給 function 內部使用不影響原本 <code>x</code> 的 Ownership，所以在呼叫完之後還是能繼續使用，然而呼叫 <code>takes_ownership</code> 時 Ownership 就轉移給 function 內部的 <code>string</code> 了，所以第七行程式碼會導致 compile error，因為 Ownership 已經被轉移了。
然後 function 也可以透過 return value 將 Ownership 轉移給呼叫方：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  <span class="hljs-keyword">let</span> s2 = takes_and_give_back(s1);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, s2);
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_give_back</span></span>(string: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
  string <span class="hljs-comment">//rust 能省略 return 直接將最後 expression 作為 return value</span>
}</code></pre><p>如此就能在呼叫 function 後繼續操控原本字串。</p>
<h3 id="references-與-borrowing"><a class="header-link" href="#references-與-borrowing"></a>References 與 Borrowing</h3>
<p>如果呼叫 function 都要上述方式將值回傳說真的也太麻煩了，在 Rust 提供了以下寫法解決這個問題：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
    <span class="hljs-keyword">let</span> len = calculate_length(&amp;s1);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;{}&#x27; is {}.&quot;</span>, s1, len);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> {
    s.len()
}</code></pre><p>上述 function <code>calculate_length</code> 會在呼叫時回傳字串長度，可以看到在呼叫 function 時傳入的是 <code>&amp;s1</code> 以及定義在 function 上的型別是 <code>&amp;String</code>，其中 <code>&amp;s1</code> 代表的是創造一個 <strong>Reference</strong> 指標指向 <code>s1</code> 指標，並沒有轉移 Ownership，<code>&amp;String</code> 則指定傳進來的要是 Reference type，所以在 calculate_length 執行完畢時，因為 s 是 Reference 指標，並沒有任何記憶體被釋放掉。在原 Scope 也能繼續使用 <code>s1</code>。</p>
<h3 id="mutable-references"><a class="header-link" href="#mutable-references"></a>Mutable References</h3>
<p>若嘗試在 function 內操作 Reference 指標更改其的值：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);
  change(&amp;s);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">change</span></span>(some_string: &amp;<span class="hljs-built_in">String</span>) {
    some_string.push_str(<span class="hljs-string">&quot;, world&quot;</span>);
}</code></pre></body>
</html>
